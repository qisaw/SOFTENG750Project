\documentclass[a4paper]{article}

\usepackage{url}
\usepackage{apacite}

\begin{document}

\title{Parallelisation Potential of Existing Serial Code}
\author{Mikhail D'Souza, Wasiq Kashkari, Sara Metz}
% \date{12/03/2014}
\maketitle

\abstract{Now that multi-core mobile phones are becoming the norm, there is
more emphasis on multi-core aware programming. This article looks at answering
the question, ``how much of the code can be parallelised?'' and ``how do we
visualize the benefits of parallelization?'' Finding and using good metrics to
gauge how much of the code can be parallelised is very hard.
This project analyse parallelisability at a superficial level and pave the way
for more advanced heuristics to come}

\section{Research Question}
\begin{description}
\item Is it feasible to predict the amount of code that can be parallelized?
\item How do we get a visual representation of the benfits of parallelizing a
piece of code?
\end{description}

\section{Motivation}
In terms of frequency, processors are beginning to peek at their physical
limits. The development and widespread public use of devices with
multiple cores is increasing rapidly. Whilst these multi-core processors are
capable of running multiple tasks at asynchronously, the majority of code in the
industry is not designed to efficiently capitalize on this capability. Thus,
these physically superior devices are inefficiently used since a large chunk of
processing power is wasted.

Developers are beginning to adapt to the changing hardware landscape.
Sequential code is being adjusted for multi-threaded environments. However this
is complicated and time consuming, especially if a developer lacks prior and
detailed knowledge of the inner workings of multiprocessing. As a result,
developing for multi-threaded environments can become difficult. Developers are
then faced with an unclear view of the cost vs benefits of parallelising a block
of code.

Our research question aims to give developers a tool to quickly and intuitively
visualise the benefits of parallelising a block of code. The point of this
exercise is not to find an accurate description of how much can be parallelised
but rather to find the methods within a package that could benefit the most from
parallelisation. Methods with the most promise of speed up from parallelisation
can be worked upon first while method with very little speedup can be neglected.

\section{Requirements}
\begin{description}
\item The program must use an efficient, algorithm to analyse code blocks
and determine whether or not that block of code is parallelizable.
\item The program must take dependencies into account to some level
\item Give the user a quick and easy way to obtain a useful visualisation
of the possible percentage speedup of a block of code.
\item Meaningfully break down the code into fractions that can and cannot
be parallelised
\item Given a java package, produce some form of speedup vs number of
processors graph
\end{description}

\section{Related Articles}
There are some tools in industry that try and do some automatic parallelisation
of some loops based on dependency analysis. This has been done using both static
analysis \cite{helixProject} and runtime analysis \cite{5470884}. However, these
tools simply try to parallelise all the code that they can, without taking
software metrics such as understandability and extensibility into account. This
can result in difficult to maintain code, which costs the developer more in the
long run.

A programmer has information not available to the algorithm such as probable
data sources/types so can make better judgements on the usefulness and method of
parallelisation. This statement has been supported by the authors of automatic
paralellization tools \cite{5470884}. Although some tools have some programmer
input (reference), none allow true programmer interaction. Facilitating a more
complete programmer interaction will be of importance in our tool.

The ability to visualise source code in a pragmatic style has been an
extensively researched problem. Large, complex systems have many sophisticated
transactions with a variety of data flow paths. It is difficult to get a clear
understanding of the system by simply analyzing code. Data visualisation tools
aim to give the developer a clear, consise overview of the system while
identifying important “hot spots”. Our project intends to complete this
\cite{488299}

In this publication \cite{pitfalls2011}, the authors talk about the many pitfalls of
parallelisation. While granularity can talk about overhead of each thread, it is
not enough to consider just that. Threads with optimal granularity but a large
amounts of dependencies will also end up being slower than serial code. The
author talk about non-negligible overheads with threads that a dependent. It is
not sufficient to look at the lines of codes by itself suggesting that the
problem proposed by this article is very much a non-trivial one but rather, a
very complex one very many variables

Many proposed approaches to parallelization use dynamic analysis of
dependencies \cite{peterson1993} \cite{1207020} \cite{Rus05hybriddependence}.
This delays parallelization until runtime, using dynamic dependence information.
We propose an approach that statically analyses source code, leaving
parallelization to the programmer who will be able to use their expertise and
intimate knowledge of the execution paths of the program to improve performance
while maintaining correctness.

\section{Design}
We will start design on the project in an agile manner. The plan is to churn out
features in an incremental fashion while testing them before moving on to the
next. The grand plan is to create a program that will be inputed a directory
full of Java code. The output will be an analysis of how much of the code in
there can be parallelised and what will be the resulting speedup for each piece
of code.

The program will calculate the total atomic lines of code. This metric will give
a good superficial count of how many atomic operations occur in a given piece of
code. The assumptions is that atomic lines of code cannot be parallelised within.
The second assumption is that all atomic lines of code that unit time to
execute. The point of this exercise is to get a very rough idea of the best case
scenario of how much time a certain piece of code will take to execute.

\section{Evaluation}
\begin{description}
\item The first method will use simple parallelization
problems that the fraction of parallelizable code can easily be calculated for.
These fractions will then be used to compare with the solution’s output. 
\item Second method to evaluate the correctness of the solution will be to run
the same simple problems on a multicore machine both serially and after being
parallelized and to compare the perceived speedup values with the calculated
speedup values produced by the solution.
\item Third method is to get code from preveious assignments and run it through
the program. The output of the program will be judged. The quality and usefulness of
the graphs produced will be evaluated.
\item The final method that will be used to evaluate the solution will be to do
a user study of the usefulness of the produced visualizations in comparison to current
parallelizable code visualization tools.
\end{description}
 
\bibliographystyle{apacite}
\bibliography{refs}
\end{document}